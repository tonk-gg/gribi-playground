{"noir_version":"0.25.0+3f676051a6073d6eabdc7fee68e4b522334344f6","hash":3392452008874266549,"abi":{"parameters":[{"name":"address","type":{"kind":"field"},"visibility":"public"},{"name":"inputs","type":{"kind":"array","length":8,"type":{"kind":"struct","path":"Input","fields":[{"name":"slot","type":{"kind":"struct","path":"std::option::Option","fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"field"}}]}},{"name":"value","type":{"kind":"struct","path":"std::option::Option","fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"field"}}]}}]}},"visibility":"public"},{"name":"operations","type":{"kind":"array","length":8,"type":{"kind":"struct","path":"Operation","fields":[{"name":"opid","type":{"kind":"struct","path":"std::option::Option","fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"field"}}]}},{"name":"value","type":{"kind":"struct","path":"std::option::Option","fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"field"}}]}},{"name":"nullifier","type":{"kind":"struct","path":"std::option::Option","fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"field"}}]}}]}},"visibility":"public"},{"name":"randomness","type":{"kind":"field"},"visibility":"private"}],"param_witnesses":{"address":[{"start":0,"end":1}],"inputs":[{"start":1,"end":33}],"operations":[{"start":33,"end":81}],"randomness":[{"start":81,"end":82}]},"return_type":null,"return_witnesses":[]},"bytecode":"H4sIAAAAAAAA/9WV12rDQBBFb+wUp/fee3UiWZItpTq9F5cfiIn9/18Q4uXKoFzyELAcyMCyOgiWmdFoTxlAGoy2+kqEe1uEO4S7hLuFe4X7hQeFh4VHhceFJ4WnhWeF54UXhZeFN4W3hXeF08IHwrawI+wJ54QD4SPhE+Ez4XPhS+Fr4Vvhe+FH4Wfh1/A5Gg3Oh7vVXNjrkbMcK+u61Vymajv2u5UJKr5nuV4l69u+7fneR8Z3nKrv+rmgEuSswHadql3zAqcWHtbKPJP/JM/VP8qz2bOL8dVsmdxS4H1molBfn/XVHu7FX+4mSmGtqUjNhcj7Mr5HIua+bMQ4C+UYe9zKmtdirLkU81wlw7Ois1CI9KJxVybDeTOO7QRn0cyQcWoP6NI+0KEDoDuHQGeOgK4cAx05AbpxCnTiDOjCOdCBC6D7lkDnrdSX+e9NH819ambIuG8LdN4O6Lo90HH7oNvMRzVOy4Auc0GHZUF3+aCzDkFXHYOOOgXdlAeddAG66Ap00A3onjvQOQ+ga55Ax7yAbnnDD/EFu7/xcskIAAA=","debug_symbols":"tZLdCsIwDEbfJde7aJq26/oq4kXVCYPRja0KMvrurrofxYLg8K4hOeejIQPUzdH6qnE9mAEoB7MboG+ti2XvbefBaGQZlO40vgQPGZyrugQj8pB9jCrFp1GVy2WUZNhnQDopV2KWa71BXqTkBaOJKAh/lwuWlEs5Ecj4l70g8nmHiHL9J7GHH//s5yk/MolLgC42BVAyANnKEL0GREakGSEWRuVvzFhcbVfZQ13Ga429izvOxzuW/tY+O+EO","file_map":{"30":{"source":"mod poseidon;\nmod mimc;\nmod poseidon2;\nmod pedersen;\n\nuse crate::default::Default;\n\n#[foreign(sha256)]\n// docs:start:sha256\npub fn sha256<N>(input: [u8; N]) -> [u8; 32]\n// docs:end:sha256\n{}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<N>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<N>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\nstruct PedersenPoint {\n   x : Field,\n   y : Field,\n}\n\npub fn pedersen_commitment<N>(input: [Field; N]) -> PedersenPoint\n// docs:end:pedersen_commitment\n{\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[foreign(pedersen_commitment)]\npub fn __pedersen_commitment_with_separator<N>(input: [Field; N], separator: u32) -> [Field; 2] {}\n\npub fn pedersen_commitment_with_separator<N>(input: [Field; N], separator: u32) -> PedersenPoint {\n    let values = __pedersen_commitment_with_separator(input, separator);\n    PedersenPoint { x: values[0], y: values[1] }\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<N>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[foreign(pedersen_hash)]\npub fn pedersen_hash_with_separator<N>(input: [Field; N], separator: u32) -> Field {}\n\npub fn hash_to_field<N>(input: [Field; N]) -> Field {\n    let mut inputs_as_bytes = [];\n\n    for i in 0..N {\n        let input_bytes = input[i].to_le_bytes(32);\n        for i in 0..32 {\n            inputs_as_bytes = inputs_as_bytes.push_back(input_bytes[i]);\n        }\n    }\n\n    let hashed_input = blake2s(inputs_as_bytes);\n    crate::field::bytes32_to_field(hashed_input)\n}\n\n#[foreign(keccak256)]\n// docs:start:keccak256\npub fn keccak256<N>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<N>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n#[foreign(sha256_compression)]\npub fn sha256_compression(_input: [u32; 16], _state: [u32; 8]) -> [u32; 8] {}\n\n// Generic hashing support. \n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\ntrait Hash{\n    fn hash<H>(self, state: &mut H) where H: Hasher;\n}\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\ntrait Hasher{\n    fn finish(self) -> Field;\n    \n    fn write(&mut self, input: [Field]);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\ntrait BuildHasher<H> where H: Hasher{\n    fn build_hasher(self) -> H;\n}\n\nstruct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default\n{\n    fn build_hasher(_self: Self) -> H{\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default\n{\n    fn default() -> Self{\n        BuildHasherDefault{}\n    }    \n}\n\n// TODO: add implementations for the remainder of primitive types.\nimpl Hash for Field{\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        let input: [Field] = [self];\n        H::write(state, input);\n    }\n}\n","path":"std/hash.nr"},"35":{"source":"struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::unsafe::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some { self._value } else { default }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    fn expect<N, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some { self } else { other }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<U, Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some { self } else { default() }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some { Option::none() } else { self }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n","path":"std/option.nr"},"47":{"source":"use dep::std;\n\nstruct Operation {\n\topid: Option<Field>,\n\tvalue: Option<Field>,\n\tnullifier: Option<Field>,\n}\n\nstruct Input {\n    slot: Option<Field>,\n    value: Option<Field>,\n}\n\n//Example signature of what a gribi module circuit looks like\n// PROOFS NOT HOOKED UP RIGHT NOW\nfn main(\n\t// TODO: IDEALLY WE GET THESE ALL THROUGH ORACLE\n\taddress: pub Field,\n\tinputs: pub [Input; 8],\n\toperations: pub [Operation; 8], //given 8 maximum, which seems like more than anyone would need\n\n\t//I mean just in case for crazy shit we keep these???\n\t// commitment_root: pub Field, \n\t// nullifier_root: pub Field,\n\t// public_root: pub Field,\n\n\t//Arbitrary private variables would go below here\n\trandomness: Field,\n) {\n\t// this means, most logic is on JS side\n\t// the circuit logic just validates \"correctness\"\n\tlet commitment = operations[0].nullifier.unwrap();\n\tlet onchain_rand = inputs[0].value.unwrap();\n\tlet index = operations[0].value.unwrap();\n\tlet computed_index = std::hash::pedersen_hash([randomness, onchain_rand, 0, 0, 0, 0, 0]);\n\tlet computed_commitment = std::hash::pedersen_hash([randomness]);\n\n\tassert(computed_commitment == commitment);\n\tassert(computed_index == index);\n}","path":"/Users/goblin/Workspace/gribi-playground/playground/hidden-assignment/circuits/reveal/src/main.nr"}}}