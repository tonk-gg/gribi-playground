{"noir_version":"0.27.0+606ff4448571b0cfe4b92420c766c4239a4b23a0","hash":17902243201616371058,"abi":{"parameters":[{"name":"address","type":{"kind":"field"},"visibility":"public"},{"name":"inputs","type":{"kind":"array","length":8,"type":{"kind":"struct","path":"Input","fields":[{"name":"slot","type":{"kind":"field"}},{"name":"value","type":{"kind":"field"}}]}},"visibility":"public"},{"name":"operations","type":{"kind":"array","length":8,"type":{"kind":"struct","path":"Operation","fields":[{"name":"opid","type":{"kind":"field"}},{"name":"value","type":{"kind":"field"}},{"name":"nullifier","type":{"kind":"field"}}]}},"visibility":"public"},{"name":"commitment_root","type":{"kind":"field"},"visibility":"public"},{"name":"nullifier_root","type":{"kind":"field"},"visibility":"public"},{"name":"public_root","type":{"kind":"field"},"visibility":"public"},{"name":"commitment","type":{"kind":"field"},"visibility":"private"},{"name":"secret","type":{"kind":"field"},"visibility":"private"},{"name":"salt","type":{"kind":"field"},"visibility":"private"}],"param_witnesses":{"address":[{"start":0,"end":1}],"commitment":[{"start":44,"end":45}],"commitment_root":[{"start":41,"end":42}],"inputs":[{"start":1,"end":17}],"nullifier_root":[{"start":42,"end":43}],"operations":[{"start":17,"end":41}],"public_root":[{"start":43,"end":44}],"salt":[{"start":46,"end":47}],"secret":[{"start":45,"end":46}]},"return_type":null,"return_witnesses":[]},"bytecode":"H4sIAAAAAAAA/9WYWW/cIBSF8SQzYWzP2n3f9zYB737z3+hjpnGkvlRV1d8f9d4GFMSgBCs3aIJ0BDPCnMMH9oyJ2HkRoH22XSJVd6rORVUUfZ31MpfHIms3TSmKclM1spFlU55kTZ73TdHU7aatRSuLvJenZZufivNyZIwlrlkwG1fC8g10BjpU9dHAWnPYM+Z9GQtxvSIF3VhCZ/yuam7k7qh8CiEn7GKj2IwS0Eh/UH0OQGP11QqvsTYZV7z1eB1FTmCL406o5w9LlrDt+8Tm0BntiTHPMXmem5qnEFytnc5OM2690fesyWrfYjU3+pgZ+A3wiwxfPba5ZrY3HYssQ++pB4upI880MIupw5uORfV/X8QeLGJHnjgwi9jhTciiRe/Eg0XiyJMEZpE4vAlZ9OiderBIHXnSwCxShzchiwK9Zx4sZo48s8AstN/QzHwHMnOrTeOdH0dqrlexmDvyzAOz0H5DM/MdyMytNo13VaH3woPFwpFnEZiF9huaOd6BzNxq03hXJXovPVgsHXmWgVksHd6ELH6g98qDxcqRZxWYhfYbmjm9hZn5DmTmVpvGuz5B77UHi7Ujzzowi7Xhrb8jPJ8Q+JzV5wG///z89ZdZxTxk2DPaIyOM7mM+1CaO6/UBxZlqmwcW3Lpev5RuHYB1jGTmkjkmQzX2V0Z3Ukl5OhcZi6hrzIonloeqbS7ASPXDRRyrRT1gF2/fuHvwTQefcPgvUf+C40LiXYO79w7oLuge6D7oAegh6BHoMegJ6CnoGeg56AXoJegV6DXoDegt6B3oPegD6CPoE+gz6AtzlH/hY+x5TxYAAA==","debug_symbols":"tdjBSsNAEIDhd9lzkOzM7M6YVxEPsVYolLS0UZCSd7elVov2kh96XHb/IYHvsntI682iH1ebYZ+6Q2pT93RI+20/nFb7sd+NqfPSNmk5vKYu2pia9LZaL1NnPjX/jkobl7OS8+9hbafnJuW7Tpdb0yPny3TN19OPgd4M7CeofwN5KLf/QL8T96uPknNS5yc+P4n5yeP8JLegyaAR0ChoDDTAQAYIMlCQAYMMHAhwIMCBAAcCHAhwIMCBAAcCHAhwIMCBAgcKHChwoMCBAgcKHChwoMCBAgcKHBhwYMCBAQcGHBhwYMCBAQcGHBhwYMBBAQ4KcFCAgwIcFOCgAAcFOCjAQQEOCnBQgYMKHFTgoAIHFTio5K4AHFTgoAIHFThw4MCBAwcOHDhw4MCBAyeXRuDAgQMHDgI4COAggIMADgI4COAggIOY6eC4+Oh3q/5lvTw9AZ323ofF5UXouBw/t+ed6Qs=","file_map":{"30":{"source":"mod poseidon;\nmod mimc;\nmod poseidon2;\nmod pedersen;\n\nuse crate::default::Default;\nuse crate::uint128::U128;\n\n#[foreign(sha256)]\n// docs:start:sha256\npub fn sha256<N>(input: [u8; N]) -> [u8; 32]\n// docs:end:sha256\n{}\n\n#[foreign(sha256)]\n// docs:start:sha256_slice\npub fn sha256_slice(input: [u8]) -> [u8; 32]\n// docs:end:sha256_slice\n{}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<N>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake2s)]\n// docs:start:blake2s_slice\npub fn blake2s_slice(input: [u8]) -> [u8; 32]\n// docs:end:blake2s_slice\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<N>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3_slice\npub fn blake3_slice(input: [u8]) -> [u8; 32]\n// docs:end:blake3_slice\n{}\n\n// docs:start:pedersen_commitment\nstruct PedersenPoint {\n   x : Field,\n   y : Field,\n}\n\npub fn pedersen_commitment<N>(input: [Field; N]) -> PedersenPoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n// docs:start:pedersen_commitment_slice\npub fn pedersen_commitment_slice(input: [Field]) -> PedersenPoint {\n    pedersen_commitment_with_separator_slice(input, 0)\n}\n// docs:end:pedersen_commitment_slice\n\n#[foreign(pedersen_commitment)]\npub fn __pedersen_commitment_with_separator<N>(input: [Field; N], separator: u32) -> [Field; 2] {}\n\n#[foreign(pedersen_commitment)]\npub fn __pedersen_commitment_with_separator_slice(input: [Field], separator: u32) -> [Field; 2] {}\n\npub fn pedersen_commitment_with_separator<N>(input: [Field; N], separator: u32) -> PedersenPoint {\n    let values = __pedersen_commitment_with_separator(input, separator);\n    PedersenPoint { x: values[0], y: values[1] }\n}\n\npub fn pedersen_commitment_with_separator_slice(input: [Field], separator: u32) -> PedersenPoint {\n    let values = __pedersen_commitment_with_separator_slice(input, separator);\n    PedersenPoint { x: values[0], y: values[1] }\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<N>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n// docs:start:pedersen_hash_slice\npub fn pedersen_hash_slice(input: [Field]) -> Field\n// docs:end:pedersen_hash_slice\n{\n    pedersen_hash_with_separator_slice(input, 0)\n}\n\n#[foreign(pedersen_hash)]\npub fn pedersen_hash_with_separator<N>(input: [Field; N], separator: u32) -> Field {}\n\n#[foreign(pedersen_hash)]\npub fn pedersen_hash_with_separator_slice(input: [Field], separator: u32) -> Field {}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut inputs_as_bytes = &[];\n\n    for input in inputs {\n        let input_bytes = input.to_le_bytes(32);\n        for i in 0..32 {\n            inputs_as_bytes = inputs_as_bytes.push_back(input_bytes[i]);\n        }\n    }\n\n    let hashed_input = blake2s_slice(inputs_as_bytes);\n    crate::field::bytes32_to_field(hashed_input)\n}\n\n#[foreign(keccak256)]\n// docs:start:keccak256\npub fn keccak256<N>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{}\n\n#[foreign(keccak256)]\n// docs:start:keccak256_slice\npub fn keccak256_slice(input: [u8], message_size: u32) -> [u8; 32]\n// docs:end:keccak256_slice\n{}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<N>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n#[foreign(sha256_compression)]\npub fn sha256_compression(_input: [u32; 16], _state: [u32; 8]) -> [u32; 8] {}\n\n// Generic hashing support. \n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\ntrait Hash{\n    fn hash<H>(self, state: &mut H) where H: Hasher;\n}\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\ntrait Hasher{\n    fn finish(self) -> Field;\n    \n    fn write(&mut self, input: [Field]);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\ntrait BuildHasher<H> where H: Hasher{\n    fn build_hasher(self) -> H;\n}\n\nstruct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default\n{\n    fn build_hasher(_self: Self) -> H{\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default\n{\n    fn default() -> Self{\n        BuildHasherDefault{}\n    }    \n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, &[self]);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, &[self as Field]);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, &[self as Field]);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, &[self as Field]);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, &[self as Field]);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, &[self as Field]);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, &[self as Field]);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, &[self as Field]);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H) where H: Hasher {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, &[self.lo as Field, self.hi as Field]);\n    }\n}\n\nimpl<T, N> Hash for [T; N] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B) where A: Hash, B: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C) where A: Hash, B: Hash, C: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D) where A: Hash, B: Hash, C: Hash, D: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E) where A: Hash, B: Hash, C: Hash, D: Hash, E: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n","path":"std/hash.nr"},"32":{"source":"mod hash;\nmod array;\nmod slice;\nmod merkle;\nmod schnorr;\nmod ecdsa_secp256k1;\nmod ecdsa_secp256r1;\nmod eddsa;\nmod grumpkin_scalar;\nmod grumpkin_scalar_mul;\nmod scalar_mul;\nmod sha256;\nmod sha512;\nmod field;\nmod ec;\nmod unsafe;\nmod collections;\nmod compat;\nmod convert;\nmod option;\nmod string;\nmod test;\nmod cmp;\nmod ops;\nmod default;\nmod prelude;\nmod uint128;\nmod bigint;\nmod internal;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained pub fn print<T>(input: T) {\n    print_oracle(false, input);\n}\n\nunconstrained pub fn println<T>(input: T) {\n    print_oracle(true, input);\n}\n\n#[foreign(recursive_aggregation)]\npub fn verify_proof<N>(verification_key: [Field], proof: [Field], public_inputs: [Field], key_hash: Field) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n// from_field and as_field are private since they are not valid for every type.\n// `as` should be the default for users to cast between primitive types, and in the future\n// traits can be used to work with generic types.\n#[builtin(from_field)]\nfn from_field<T>(x: Field) -> T {}\n\n#[builtin(as_field)]\nfn as_field<T>(x: T) -> Field {}\n\npub fn wrapping_add<T>(x: T, y: T) -> T {\n    crate::from_field(crate::as_field(x) + crate::as_field(y))\n}\n\npub fn wrapping_sub<T>(x: T, y: T) -> T {\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    crate::from_field(crate::as_field(x) + 340282366920938463463374607431768211456 - crate::as_field(y))\n}\n\npub fn wrapping_mul<T>(x: T, y: T) -> T {\n    crate::from_field(crate::as_field(x) * crate::as_field(y))\n}\n","path":"std/lib.nr"},"47":{"source":"use dep::std;\n\nstruct Operation {\n\topid: Field,\n\tvalue: Field,\n\tnullifier: Field,\n}\n\nstruct Input {\n    slot: Field,\n    value: Field,\n}\n\n//Example signature of what a gribi module circuit looks like\nfn main(\n\t// TODO: IDEALLY WE GET THESE ALL THROUGH ORACLE\n\taddress: pub Field,\n\tinputs: pub [Input; 8],\n\toperations: pub [Operation; 8], //given 8 maximum, which seems like more than anyone would need\n\n\t//I mean just in case for crazy shit we keep these???\n\tcommitment_root: pub Field, \n\tnullifier_root: pub Field,\n\tpublic_root: pub Field,\n\n\t//Arbitrary private variables would go below here\n\tcommitment: Field,\n\tsecret: Field,\n\tsalt: Field\n) {\n\t// this means, most logic is on JS side\n\t// the circuit logic just validates correctness\n\tlet commit = std::hash::pedersen_hash([secret, salt, 0, 0, 0, 0, 0, 0]);\n\tstd::println(commit);\n\tassert(commitment == commit);\n}\n\n#[test]\nfn test_main() {\n\tlet commitment = 0x21c418d83d736aad0860803c962fec2a567ca98c4cbb9a0cec65a68afe12cbfb;\n\tlet secret = 0x0;\n\tlet salt = 0xe8e1fd548995aa1780235b32ca5195050f898d9aecfba4009388824898f82d;\n\tlet address = 0xabcdef123456789;\n\tlet inputs = [Input { slot: 0, value: 0 }; 8]; // Assuming default values for slot and value\n\tlet operations = [Operation { opid: 0, value: 0, nullifier: 0 }; 8]; // Assuming default values for opid, value, and nullifier\n\tlet commitment_root = 0x292099dc682fac02111f941c6058b2b137b25ed83ac9b823f973f2021eb835e3;\n\tlet nullifier_root = 0xabcdef123456789;\n\tlet public_root = 0xabcdef123456789;\n\n\tmain(address, inputs, operations, commitment_root, nullifier_root, public_root, commitment, secret, salt);\n}\n\n","path":"/Users/goblin/Workspace/gribi-playground/playground/modules/commit-update-reveal/circuits/commit/src/main.nr"}},"names":["main"]}